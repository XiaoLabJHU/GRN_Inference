"""
This module contains functions to build MI matrices that can be used downstream to reconstruct the GRN.
Default results are in [nats] = natural log using np.log().
Written by Lior Shachaf 2021-02-09.
"""

import numpy as np
import scipy.io
import Mutual_Info_based_binning_module as MI_binning_mod
import Mutual_Info_KNN_nats_module as MI_KNN_mod


def import_and_clean_input_file(input_file):
    """
    Build a 2D array of genes (Y-axis) and conditions (X-axis) based on expression data file generated by GeneNetWeaver.

    Parameters:
    input_file (str): Path to the input file.

    Returns:
    np.ndarray: 2D array with genes as rows and conditions as columns.
    """
    with open(input_file) as in1:
        in1_data = in1.readlines()

    # Building array of genes (Y-axis) and conditions (X-axis)
    if "G1" in in1_data[0]:  # Skips the header line
        print("G1!")
        in1_data.pop(0)

    num_genes = len(in1_data[0].split('\t'))
    num_conditions = len(in1_data)
    in1_data_array = np.zeros((num_genes, num_conditions), dtype=float)

    for line_num, line in enumerate(in1_data):
        expression_data_tmp = line.split('\t')
        for gene_num, gene in enumerate(expression_data_tmp):
            in1_data_array[gene_num][line_num] = float(gene)

    return in1_data_array


def calc_bins_num(input_file, binning_rule, min_range=2, max_range=20, interval=2):
    """
    Calculate the number of bins based on the binning rule.

    This function reads the input file to determine the number of conditions (X-axis) and calculates the number of bins
    based on the specified binning rule. It supports "Sturges", "Sqrt", and "range" binning rules.

    Parameters:
    input_file (str): Path to the input file.
    binning_rule (str): Binning rule to use ("Sturges", "Sqrt", or "range").
    min_range (int, optional): Minimum number of bins for the "range" binning rule. Default is 2.
    max_range (int, optional): Maximum number of bins for the "range" binning rule. Default is 20.
    interval (int, optional): Interval between bins for the "range" binning rule. Default is 2.

    Returns:
    tuple: A tuple containing the minimum number of bins, maximum number of bins, and interval between bins.

    Raises:
    ValueError: If an invalid binning rule is provided.
    """
    # Get the number of conditions (X-axis).
    with open(input_file) as in1:
        in1_data = in1.readlines()
    if "G1" in in1_data[0]:  # Skips the header line
        data_size = len(in1_data) - 1
    else:
        data_size = len(in1_data)

    # Calculate the number of bins based on the binning rule.
    if binning_rule == "Sturges":
        min_range = max_range = int(np.ceil(np.log2(data_size)) + 1)
        return min_range, max_range, 1
    elif binning_rule == "Sqrt":
        # return int(np.ceil(np.sqrt(data_size)))  # used prior to Sep-24-2021
        min_range = max_range = int(np.floor(np.sqrt(data_size)))  # same as the R-package Minet
        return min_range, max_range, 1
    elif binning_rule == "range":
        return min_range, max_range, interval
    else:
        raise ValueError(f"Invalid binning rule: {binning_rule}")


def get_dict_name(mi, bins_or_neighbors, mi_est):
    """
    Get the dictionary name based on the bins / neighbors and the mutual information estimator.

    Parameters:
    mi (str): Mutual information measure ("MI2", "TC").
    bins_or_neighbors (int): Number of bins or neighbors.
    mi_est (str): Mutual information estimator ("Shannon", "Miller-Madow", "KSG", "KL").

    Returns:
    str: Dictionary name.
    """
    if mi_est == "Shannon":
        return f'{mi}_FB{bins_or_neighbors}_Shan'
    elif mi_est == "Miller-Madow":
        return f'{mi}_FB{bins_or_neighbors}_MM'
    elif mi_est in ["KSG", "KL"]:
        return f'{mi}_KNN{bins_or_neighbors}_{mi_est}'
    else:
        raise ValueError(f"Invalid mutual information estimator: {mi_est}")


def get_entropy_function(mi_est):
    """
    Get the appropriate entropy function based on the mutual information estimator.

    Parameters:
    mi_est (str): Mutual information estimator ("Shannon", "Miller-Madow", "KL").

    Returns:
    function: The appropriate entropy function.
    """
    if mi_est in ["Shannon", "Miller-Madow"]:
        return MI_binning_mod.entropy
    elif mi_est == "KL":
        return MI_KNN_mod.entropy_knn_kdtree_algo
    else:
        raise ValueError(f"Invalid mutual information estimator: {mi_est}")


def mi2_matrix_build(input_file_name, in1_data_array, bins_or_neighbors, mi_est, self_info=False):
    """
    Build MI2 matrix by calculating a half diagonal matrix and completing the other half.

    Parameters:
    input_file_name (str): Name of the input file.
    in1_data_array (np.ndarray): 2D array with genes as rows and conditions as columns.
    bins_or_neighbors (int): Number of bins or neighbors.
    mi_est (str): Mutual information estimator ("Shannon", "Miller-Madow", "KSG", "KL").
    self_info (bool, optional): If True, calculate self-information (entropy) for each gene. Default is False.

    Returns:
    None
    """
    mi_measure = "MI2"
    if mi_est in ["Shannon", "Miller-Madow"]:
        MI2_matrix = np.zeros((in1_data_array.shape[0], in1_data_array.shape[0]), dtype=float)
    elif mi_est in ["KL", "KSG"]:
        k_max = bins_or_neighbors
        MI2_matrix = np.zeros((in1_data_array.shape[0], in1_data_array.shape[0], k_max), dtype=float)

    if mi_est == "KSG":
        for gene1 in range(in1_data_array.shape[0]):
            for gene2 in range(gene1, in1_data_array.shape[0]):
                if gene2 == gene1 and not self_info:
                    continue
                MI2_matrix[gene1, gene2, :] = MI_KNN_mod.mi_knn_kdtree_algo(in1_data_array[gene1], in1_data_array[gene2],
                                                                            bins_or_neighbors)
                # Completing the half diagonal matrix
                MI2_matrix[gene2, gene1, :] = MI2_matrix[gene1, gene2, :]

    else:
        # Determine the correct function to use to calculate MI2
        entropy_func = get_entropy_function(mi_est)

        for gene1 in range(in1_data_array.shape[0]):
            G0 = in1_data_array[gene1]
            Ex = entropy_func(G0, bins_or_neighbors=bins_or_neighbors, mi_est=mi_est)

            for gene2 in range(gene1, in1_data_array.shape[0]):
                if gene2 == gene1 and not self_info:
                    continue
                G1 = in1_data_array[gene2]
                Ey = entropy_func(G1, bins_or_neighbors=bins_or_neighbors, mi_est=mi_est)
                Exy = entropy_func(G0, G1, bins_or_neighbors=bins_or_neighbors, mi_est=mi_est)
                """if mi_est in ["Shannon", "Miller-Madow"]:"""
                MI2_matrix[gene1, gene2] = MI_binning_mod.two_way_info_from_entropy(Ex, Ey, Exy)
                # Completing the half diagonal matrix
                MI2_matrix[gene2, gene1] = MI2_matrix[gene1, gene2]
                """elif mi_est in ["KL"]:
                    MI2_matrix[gene1, gene2, :] = MI_binning_mod.two_way_info_from_entropy(Ex, Ey, Exy)
                    # Completing the half diagonal matrix
                    MI2_matrix[gene2, gene1, :] = MI2_matrix[gene1, gene2, :]"""

    # Saving to a mat file
    dict_name = get_dict_name(mi_measure, bins_or_neighbors, mi_est)
    matfile = f"{input_file_name[:-4]}_{dict_name}.mat"
    scipy.io.savemat(matfile, mdict={dict_name: MI2_matrix})

    print("Done building MI2 matrix")


def tc_matrix_build(input_file_name, in1_data_array, bins_or_neighbors, mi_est):
    """
    Build TC matrix by calculating a half diagonal matrix and completing the other half.

    Parameters:
    input_file_name (str): Name of the input file.
    in1_data_array (np.ndarray): 2D array with genes as rows and conditions as columns.
    bins_or_neighbors (int): Number of bins or neighbors.
    mi_est (str): Mutual information estimator ("KSG").

    Returns:
    None
    """
    mi_measure = "TC"
    # Determine the correct function to use to calculate TC
    if mi_est in ["Shannon", "Miller-Madow", "KL"]:
        tc_matrix_build_from_entropies(input_file_name, in1_data_array, bins_or_neighbors, mi_est)
        return None  # Exit the function

    k_max = bins_or_neighbors
    TC_matrix = np.zeros((in1_data_array.shape[0], in1_data_array.shape[0], in1_data_array.shape[0], k_max), dtype=float)

    for gene1 in range(in1_data_array.shape[0]):
        for gene2 in range(gene1, in1_data_array.shape[0]):
            if gene2 == gene1:  # Skip self-information (entropy)
                continue
            for gene3 in range(gene2, in1_data_array.shape[0]):
                if gene3 == gene2 or gene3 == gene1:  # Skip self-information (entropy)
                    continue

                G0 = in1_data_array[gene1]
                G1 = in1_data_array[gene2]
                G2 = in1_data_array[gene3]

                TC_matrix[gene1, gene2, gene3, :] = MI_KNN_mod.tc_knn_kdtree_algo(G0, G1, G2, k_max)

                # Completing the matrix
                TC_matrix[gene1, gene3, gene2] = TC_matrix[gene1, gene2, gene3]
                TC_matrix[gene2, gene1, gene3] = TC_matrix[gene1, gene2, gene3]
                TC_matrix[gene2, gene3, gene1] = TC_matrix[gene1, gene2, gene3]
                TC_matrix[gene3, gene1, gene2] = TC_matrix[gene1, gene2, gene3]
                TC_matrix[gene3, gene2, gene1] = TC_matrix[gene1, gene2, gene3]

    # Saving to a mat file
    dict_name = get_dict_name(mi_measure, bins_or_neighbors, mi_est)
    matfile = f"{input_file_name[:-4]}_{dict_name}.mat"
    scipy.io.savemat(matfile, mdict={dict_name: TC_matrix})

    print("Done building TC matrix")


def tc_matrix_build_from_entropies(input_file_name, in1_data_array, bins_or_neighbors, mi_est):
    """
    Build TC matrix by calculating a half diagonal matrix and completing the other half.

    Parameters:
    input_file_name (str): Name of the input file.
    in1_data_array (np.ndarray): 2D array with genes as rows and conditions as columns.
    bins_or_neighbors (int): Number of bins or neighbors.
    mi_est (str): Mutual information estimator ("Shannon", "Miller-Madow", "KL").

    Returns:
    None
    """
    mi = "TC"
    entropy_func = get_entropy_function(mi_est)

    if mi_est in ["Shannon", "Miller-Madow"]:
        TC_matrix = np.zeros((in1_data_array.shape[0], in1_data_array.shape[0], in1_data_array.shape[0]), dtype=float)
    elif mi_est in ["KL"]:
        k_max = bins_or_neighbors
        TC_matrix = np.zeros((in1_data_array.shape[0], in1_data_array.shape[0], in1_data_array.shape[0], k_max), dtype=float)

    for gene1 in range(in1_data_array.shape[0]):
        G0 = in1_data_array[gene1]
        Ex = entropy_func(G0, bins_or_neighbors=bins_or_neighbors, mi_est=mi_est)

        for gene2 in range(gene1, in1_data_array.shape[0]):
            if gene2 == gene1:  # Skip self-information (entropy)
                continue
            G1 = in1_data_array[gene2]
            Ey = entropy_func(G1, bins_or_neighbors=bins_or_neighbors, mi_est=mi_est)

            for gene3 in range(gene2, in1_data_array.shape[0]):
                if gene3 == gene2:  # Skip self-information (entropy)
                    continue
                G2 = in1_data_array[gene3]
                Ez = entropy_func(G2, bins_or_neighbors=bins_or_neighbors, mi_est=mi_est)
                Exyz = entropy_func(G0, G1, G2, bins_or_neighbors=bins_or_neighbors, mi_est=mi_est)
                TC_matrix[gene1, gene2, gene3] = MI_binning_mod.total_corr_from_entropy(Ex, Ey, Ez, Exyz)
                """TC_matrix[gene1, gene2, gene3, :] = MI_binning_mod.total_corr_from_entropy(Ex, Ey, Ez, Exyz)"""

                # Completing the matrix
                TC_matrix[gene1, gene3, gene2] = TC_matrix[gene1, gene2, gene3]
                TC_matrix[gene2, gene1, gene3] = TC_matrix[gene1, gene2, gene3]
                TC_matrix[gene2, gene3, gene1] = TC_matrix[gene1, gene2, gene3]
                TC_matrix[gene3, gene1, gene2] = TC_matrix[gene1, gene2, gene3]
                TC_matrix[gene3, gene2, gene1] = TC_matrix[gene1, gene2, gene3]

    # Replacing -inf and +inf values with zero
    TC_matrix[np.isneginf(TC_matrix)] = 0
    TC_matrix[np.isposinf(TC_matrix)] = 0

    # Saving to a mat file
    dict_name = get_dict_name(mi, bins_or_neighbors, mi_est)
    matfile = f"{input_file_name[:-4]}_{dict_name}.mat"
    scipy.io.savemat(matfile, mdict={dict_name: TC_matrix})

    print("Done building TC matrix")


def generate_mi_db_output(input_file_name, bins_num, mi_est, include_tc=False):
    """
    Generate mutual information (MI) or total correlation (TC) database output.

    This function decides whether to generate an MI database or a TC database based on the `include_tc` flag.
    It delegates the task to either `building_mi_DB` or `building_tc_DB`.

    Parameters:
    input_file_name (str): Name of the input file.
    bins_num (int): Number of bins or neighbors.
    mi_est (str): Mutual information estimator ("Shannon", "Miller-Madow", "KSG", "KL").
    include_tc (bool, optional): If True, generate a TC database. If False, generate an MI database. Default is False.

    Returns:
    None
    """
    if include_tc:
        building_tc_DB(input_file_name, bins_num, mi_est)
    else:
        building_mi_DB(input_file_name, bins_num, mi_est)


def building_mi_DB(input_file_name, bins_num, mi_est):
    """
    Build a database file with mutual information (MI) values and optionally total correlation (TC) values.

    The database file includes: X#, Y#, X-name, Y-name, MI(X,Y).

    Parameters:
    input_file_name (str): Name of the input file.
    bins_num (int): Number of bins or neighbors.
    mi_est (str): Mutual information estimator ("Shannon", "Miller-Madow", "KSG", "KL").

    Returns:
    None
    """
    # Load data files
    dict_name_MI2 = input_file_name[:-4].split("all_")[1]
    matdata1 = scipy.io.loadmat(input_file_name)
    MI2_matrix_tmp = matdata1[dict_name_MI2]

    # Remove the k dimension from the mat file (4D) by saving to a new matrix with a specific k
    if mi_est in ["KSG", "KL"]:
        MI2_matrix = MI2_matrix_tmp[:, :, bins_num - 1]
        # Determine the output file name
        output_file = f"{input_file_name[:-4].split('_MI2_KNN')[0]}_MI2_KNN{bins_num}_{mi_est}.dat"
    else:
        MI2_matrix = MI2_matrix_tmp
        # Determine the output file name
        output_file = f"{input_file_name[:-4]}.dat"

    # Write to file
    with open(output_file, "w") as out1:
        for i in range(MI2_matrix.shape[0]):
            for j in range(MI2_matrix.shape[1]):
                if i == j:
                    continue
                # DB should include: X#, Y#, X-name, Y-name, MI(X,Y)
                out1.write(f"{i:2d},{j:2d},G{i},G{j},{MI2_matrix[i, j]:2.9f}\n")

    print(f"Done writing to file {output_file}")


def building_tc_DB(input_file_name, bins_num, mi_est):
    """
    Build a database file with mutual information (MI) values and optionally total correlation (TC) values.

    The database file includes: X#, Y#, Z#, X-name, Y-name, Z-name, MI(X,Y), MI(X,Z), MI(Y,Z), TC.

    Parameters:
    input_file_name (str): Name of the input file.
    bins_num (int): Number of bins or neighbors.
    mi_est (str): Mutual information estimator ("Shannon", "Miller-Madow", "KSG", "KL").

    Returns:
    None
    """
    # Load data files
    dict_name_MI2 = input_file_name[:-4].split("all_")[1].replace("TC", "MI2")
    matdata1 = scipy.io.loadmat(input_file_name.replace("TC", "MI2"))
    MI2_matrix_tmp = matdata1[dict_name_MI2]
    dict_name_TC = input_file_name[:-4].split("all_")[1]
    matdata2 = scipy.io.loadmat(input_file_name)
    TC_matrix_tmp = matdata2[dict_name_TC]

    # Remove the k dimension from the mat file (4D) by saving to a new matrix with a specific k
    if mi_est in ["KSG", "KL"]:
        MI2_matrix = MI2_matrix_tmp[:, :, bins_num - 1]
        TC_matrix = TC_matrix_tmp[:, :, :, bins_num - 1]
        # Determine the output file name
        output_file = f"{input_file_name[:-4].split('_TC_KNN')[0]}_MI2andTC_KNN{bins_num}_{mi_est}.dat"
    else:
        MI2_matrix = MI2_matrix_tmp
        TC_matrix = TC_matrix_tmp
        # Determine the output file name
        output_file = f"{input_file_name[:-4].replace('TC', 'MI2andTC')}.dat"

    # Write to file
    with open(output_file, "w") as out1:
        for i in range(TC_matrix.shape[0]):
            for j in range(TC_matrix.shape[1]):
                if i == j:
                    continue
                for m in range(TC_matrix.shape[2]):
                    if m == i or m == j:
                        continue
                    # DB should include: X#, Y#, Z#, X-name, Y-name, Z-name, MI(X,Y), MI(X,Z), MI(Y,Z), TC
                    out1.write(f"{i:2d},{j:2d},{m:2d},G{i},G{j},G{m},{MI2_matrix[i, j]:2.9f},{MI2_matrix[i, m]:2.9f},"
                               f"{MI2_matrix[j, m]:2.9f},{TC_matrix[i, j, m]:2.9f}\n")

    print(f"Done writing to file {output_file}")
